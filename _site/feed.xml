<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mattgreen</title>
    <description>Hi! I&#39;m a developer currently working at Net-A-Porter. I have a keen interest in all things Web, with a particular focus on web performance. Blog posts will be a collection of my findings/musings on this subject. Enjoy!
</description>
    <link>https://mattgreen.io/</link>
    <atom:link href="https://mattgreen.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 20 Feb 2016 17:44:03 +0000</pubDate>
    <lastBuildDate>Sat, 20 Feb 2016 17:44:03 +0000</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>Profile Driven Development</title>
        <description>&lt;p&gt;Now, don’t worry. I’m not here to force a new programming methodoligy upon you. Instead I want to highlight how profiling can, and should, be an important part of your development process, and how it can help produce quality code.&lt;/p&gt;

&lt;p&gt;A few months ago, we (the tech team for Net-A-Porter.com) were getting ready to launch our newest application - a new webapp to serve all of our product pages. But during load testing, we noticed very high levels of CPU on the server.&lt;/p&gt;

&lt;p&gt;As far as the server is concerned, it’s a fairly simple app. Written in Node.js, it makes HTTP requests to a couple of our internal APIs, and then spits out some HTML. Therefore high CPU levels seemed odd for a process which doesn’t do much in the way of CPU-intensive work. Some investigation needed to occur.&lt;/p&gt;

&lt;h3 id=&quot;introducing-the-v8-profiler&quot;&gt;Introducing the V8-profiler&lt;/h3&gt;

&lt;p&gt;I’m not overly familiar with profiling tools, but after a small bit of internet-ing I came across the &lt;a href=&quot;https://www.npmjs.com/package/v8-profiler&quot;&gt;v8-profiler&lt;/a&gt;. We use Express for our web framework, so I started profiling at the entry point of a request:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;profiler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;v8-profiler&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;/:countryIso/:langIso/product/:pid&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;profiler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startProfiling&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;product-page&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// more middleware&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Then, I stop profiling just before sending the payload back to the user, and save the profile data to disk:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cpuProfile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;profiler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stopProfiling&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;product-page&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;cpuProfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;writeFileSync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;profile.cpuprofile&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cpuProfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;By using the extension .cpuprofile, the saved data can be loaded into Chrome’s profiles panel in DevTools, giving a nice graphic of what’s going on:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/profile-driven-development/profile_before.png&quot; alt=&quot;Load profiles into Chrome for useful charts&quot; /&gt;
&lt;em&gt;Load profiles into Chrome for useful charts&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;spotting-the-bottleneck&quot;&gt;Spotting the bottleneck&lt;/h3&gt;

&lt;p&gt;This may look very confusing at first. Express uses the middleware pattern, meaning that the call stack gets deeper as you go through the chain of middleware. Each time you see ‘next’ followed by ‘handle’, it means Express is going to the next piece of middleware. The way to then spot a bottleneck in this chart is to look for two instances of ‘next’ being called with a large amount of time between them.&lt;/p&gt;

&lt;p&gt;In this case, a lot of time is being spent doing some sort of compiling:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/profile-driven-development/profile_before_highlighted.png&quot; alt=&quot;Visualising the data makes problems easy to spot&quot; /&gt;
&lt;em&gt;Visualising the data makes problems easy to spot&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Looking at the code, I realise that we’re using &lt;a href=&quot;http://handlebarsjs.com/&quot;&gt;Handlebars&lt;/a&gt; to convert template URLs into actual URLs. But the real crippling factor, is that we’re re-compiling the template string &lt;em&gt;every time&lt;/em&gt; we generate a URL. Compilation of a template string into a compiled temaplte is slow - intentionally so. By doing most of the work up-front, the runtime action of turning a compiled template into a populated string can be made as fast as possible.&lt;/p&gt;

&lt;p&gt;With this information uncovered, a fix is easy. We &lt;em&gt;could&lt;/em&gt; compile the template string and save it for re-use. But, the template is slightly different for each product on the website, so we’d have to do at least one compilation per request. A better alternative, which avoids the use of a library entirely, is to simply use &lt;code&gt;String.replace()&lt;/code&gt; to replace each variable in the string for the value we want.&lt;/p&gt;

&lt;h3 id=&quot;the-results&quot;&gt;The Results&lt;/h3&gt;

&lt;p&gt;Running the improved code through the V8-profiler again yeilds this profile chart:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/profile-driven-development/profile_after_highlighted.png&quot; alt=&quot;Ahh, much better&quot; /&gt;
&lt;em&gt;Ahh, much better&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The bits highlighted in the red box are the pieces of middleware which were previously taking a long time. Now they are quick enough for the profile to consider them taking zero time.&lt;/p&gt;

&lt;p&gt;The impact on CPU was clear as well. When put through another load test, rather than CPU being pegged at 95-100% for the duration, it increased and decreased with the amount of load being put through it. This is exactly what we’d expect to see from a system such as this.&lt;/p&gt;

&lt;p&gt;Whilst this bit of code doesn’t need optimising any further yet, this did get me thinking - is &lt;code&gt;String.replace()&lt;/code&gt; the best method for this task? For the answer to that, you have to wait until next time…&lt;/p&gt;
</description>
        <pubDate>Sat, 20 Feb 2016 20:11:00 +0000</pubDate>
        <link>https://mattgreen.io/2016/02/20/profile-driven-development.html</link>
        <guid isPermaLink="true">https://mattgreen.io/2016/02/20/profile-driven-development.html</guid>
        
        
      </item>
    
  </channel>
</rss>
